# ECache - Java cache library

ECache - это Spring Java библиотека для кэширования HTTP-запросов.

ECache работает на основе HTTP-заголовка ETag. Главное отличие ECache от последнего
в том, что для вычисления значения ETag и передачи ответа со статусом 304 при
попадании в кэш не выполняется бизнес логика приложения и чтение базы данных, 
что в определенных условиях приводит к дополнительному увеличению 
скорости работы.

ETag формируется из имен таблиц базы данных, используемых для формирования
ответа на кэшируемый запрос, а также идентификаторов состояний этих таблиц.
При этом в памяти хранятся не полные закэшированные ответы, а лишь 
названия таблиц и ID состояний этих таблиц, что практически не сказывается 
на расходуемой оперативной памяти.

Обновление идентификаторов состояний таблиц в случае выполнения 
операций вставки/удаления/модификации для этих таблиц берет на себя ECache. 
Для начала работы пользователю библиотеки остается только указать таблицы, которые
используются при обработке кэшируемого запроса, а также участки кода, 
которые модифицируют состояние этих таблиц.

## Добавление в проект

Для начала работы достаточно добавить зависимость:

```
<dependency>
    <groupId>ru.ecache</groupId>
    <artifactId>e-cache</artifactId>
    <version>0.1</version>
</dependency>
```

## Использование

### Выделение кэшируемых запросов

Для выделения кэшируемых запросов используется аннотация `@ECache` уровня 
метода. С помощью параметра 
tables можно указать имена таблиц, которые используются для построения ответа 
на данный запрос. С помощью параметра entities можно указать JPA-сущности 
(`@Entity`), которые используются для построения ответа на данный запрос 
(поддерживается только реализация Hibernate).

Пример использования аннотации `@ECache` для методов контроллеров:

```java
@ECache(tables = {"Organizer"}, entities = {PersonEntity.class})
@GetMapping("/organizer/{id}")
public ResponseEntity<Organizer> getOrganizers(
        @RequestHeader(name = HttpHeaders.IF_NONE_MATCH, required = false) String ifNoneMatch,
        @PathVariable(name = "size") int id) {

    Organizer organizer = organizerService.findById(id);

    return ResponseEntity.ok()
            .body(organizer);
}
```

После этого в ответы для данного запроса будет автоматически подставляться 
вычисленный заголовок ETag. Вычисление ETag происходит до передачи управления 
методу getOrganizers. В случае, если значение полученного If-None-Match 
HTTP-заголока совпадает со значением вычисленного ETag, то будет возвращаен ответ 
без тела и со статусом 304. При этом управление методу getOrganizers передаваться 
не будет.

В текущей версии библиотеки 0.1 в кэшируемых методах контроллеров обязательно 
указывать параметр с If-None-Match HTTP-заголовком. Также метод контроллера должен
возвращать ResponseEntity.

### Выделение участков кода, модифицирующих состояние таблиц

Для этого используется аннотация `@ECacheEvict` уровня метода. Этой аннотации 
так же в параметрах можно указать названия таблиц, 
состояние которых будет обновляться при вызове данного метода.

Пример использования аннотации `@ECacheEvict` для DAO-классов:

```java
@ECacheEvict(tables = {"Organizer"})
public void update(Organizer organizer) {
    jdbc.update(UPDATE, organizer.getName(), organizer.getId());
}
```

Теперь после вызова метода update для таблицы Organizer будет обновлен ID
состояния. Это приведет к тому, что везде, где в `@ECache` 
указана таблица "Organizer"
при следующей обработке запроса изменится значение ETag, 
что приведет к полной обработке запроса без использования кэша.

***Названия таблиц для аннотаций `@ECache` и `@ECacheEvict` не обязательно должны
совпадать c реальными названиями таблиц БД. Достаточно, чтобы и в 
`@ECache`, и в `@ECacheEvict`использовалось одно и то же название 
для одной и той же таблицы.***

### Выделение отслеживаемых JPA-сущностей

Для этого нужно зарегистрировать bean в контексте Spring с заполненным 
`EEntitiesCacheStore`.
Этому классу нужно указать: модификация каких JPA-сущностей 
должна отслеживаться. Создание `EEntitiesCacheStore` является необазательным, 
если при кэшировании вы не будете использовать отслеживание JPA-сущностей.

Пример создания и заполнения `EEntitiesCacheStore`.

```java
@Bean
public EEntitiesCacheStore eCacheEntitiesStore() {
    EEntitiesCacheStore store = new EEntitiesCacheStore();
    store.addEntity(PersonEntity.class);
    return store;
}
```

После этого в случае модификации сущности PersonEntity везде, 
где в `@ECache` указана эта сущность
при следующей обработке запроса изменится значение ETag. 
Это приведет к полной обработке запроса без использования кэша.

### Выбор хранилища

Для начала работы необходимо выбрать хранилище для названий таблиц и ID 
их состояний. Для этого нужно зарегистрировать bean `ECacheService` в контексте 
Spring. Это действие является обязательным.

#### Локальное хранилище

Пример выбора локального хранилища. 

```java
@Bean
public ECacheService<String, Long> getCache(ECacheManager cacheManager) {
    return cacheManager.getCache(ECacheName.LOCAL_CACHE.getName());
}
```

В этом случае для хранения будет использоваться внутренняя память Java-приложения.

#### Разделяемое хранилище

Можно выбрать разделяемое хранилище для использования, например, в приложениях
на базе микросервисной архитектуры. В текущей версии библиотеки 0.1 добавлена
поддержка разделяемого хранилища только на основе Redis.

Пример выбора разделяемого хранилища. 

```java
@Bean
public ECacheService<String, Long> getCache(ECacheManager cacheManager) {
    return cacheManager.getCache(ECacheName.REDIS_CACHE.getName());
}
```

При выборе разделяемого хранилища на основе Redis нужно также указать host и port
запущенного сервера Redis. Сделать это можно с помощью property-файла:

```
ecache.store.redis-host=localhost
ecache.store.redis-port=6379
```
